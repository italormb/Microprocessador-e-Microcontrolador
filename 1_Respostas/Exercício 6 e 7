Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma 
questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize 
adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1.(a) Escreva uma função em C que calcule a raiz quadrada x de uma variável S do tipo float, utilizando o seguinte algoritmo: 
após n+1 iterações, a raiz quadrada de S é dada por:

x(n+1) = (x(n) + S/x(n))/2

O protótipo da função é:

#include <stdio.h>
unsigned int Raiz_Quadrada(unsigned int s)
{
    unsigned int x=1,p=s;
    while(p>0){
    p-=1;
    x=(((s/x)+x)/2);
    }
    return x;
}

main(){
    unsigned int s=0,x;
    printf("Digite o numero para tirar raiz:\n");
    scanf("%d",&s);
    x=Raiz_Quadrada(s);
    printf("%d\n",x);
}


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável S é fornecida pelo registrador R15, e a raiz 
quadrada de S (ou seja, a variável x) é fornecida pelo registrador R15 também.

2.(a) Escreva uma função em C que calcule x elevado à N-ésima potência, seguindo o seguinte protótipo:

/*int Potencia(int x, int N){
int x,N,i;
for(i<n; i=0; i++){
x*=x;
}
return x;
}*/

#include <stdio.h>

int MULT_unsigned(int a, int b)
{
if(b==0) return 0;
else
return (a+MULT_unsigned(a, b-1));
}
int MULT_signed(int a, int b)
{
	if(a<0 && b<0)
	{	a = -a;
		b = -b;
		return MULT_unsigned(a,b);
	}
	else if (a<0 && b>0)
	{	a = -a;
		return -(MULT_unsigned(a,b));
	}
	else if (a>0 && b<0)
	{	b = -b;
		return -(MULT_unsigned(a,b));
	}
	else
	{	return MULT_unsigned(a,b);
	}

}
int Potencia(int x, int     N){

    if(N==0) return 1;
    else   return(MULT_signed(x,Potencia(x,N-1)));
}

int main(){
    int N,x,resultado=0;
    printf("Escreva os fatores do produto:\n");
    scanf("%d\n%d",&x,&N);
    resultado=Potencia(x,N);

    printf("%d\n",resultado);
}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. x e n são fornecidos através dos registradores R15 e R14, 
respectivamente, e a saída deverá ser fornecida no registrador R15.

3.Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de a por b, onde a, b e o valor de saída são inteiros 
de 16 bits. a e b são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do 
registrador R15.
em c:
#include <stdio.h>

int MULT_unsigned(int a, int b)
{
if(b==0) return 0;
else
return (a+MULT_unsigned(a, b-1));
}
int MULT_signed(int a, int b)
{
	if(a<0 && b<0)
	{	a = -a;
		b = -b;
		return MULT_unsigned(a,b);
	}
	else if (a<0 && b>0)
	{	a = -a;
		return -(MULT_unsigned(a,b));
	}
	else if (a>0 && b<0)
	{	b = -b;
		return -(MULT_unsigned(a,b));
	}
	else
	{	return MULT_unsigned(a,b);
	}

}
int div(int D, int q){
    int i=0,aux=q;
 while(aux < D || aux==D){
    i++;
    aux=aux+q;
    }
    return i;
}

int main(){
    int D,q,resto;
    printf("Escreva o Divisor,quociente:\n");
    scanf("%i\n",&D);
    scanf("%i\n",&q);
    resto=div(D,q);
    printf("%d\n",resto);
}

em assembly:

4.Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de a por b, onde a, b e o valor de saída 
são inteiros de 16 bits. a e b são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida
através do registrador R15.
em c:
#include <stdio.h>

int MULT_unsigned(int a, int b)
{
if(b==0) return 0;
else
return (a+MULT_unsigned(a, b-1));
}
int MULT_signed(int a, int b)
{
	if(a<0 && b<0)
	{	a = -a;
		b = -b;
		return MULT_unsigned(a,b);
	}
	else if (a<0 && b>0)
	{	a = -a;
		return -(MULT_unsigned(a,b));
	}
	else if (a>0 && b<0)
	{	b = -b;
		return -(MULT_unsigned(a,b));
	}
	else
	{	return MULT_unsigned(a,b);
	}

}
int div(int D, int q){
    int i=0,aux=q;
 while(aux < D || aux==D){
    i++;
    aux=aux+q;
    }
    return i;
}
int res_div(int D, int d,int q){
    return (D-MULT_signed(q,d));

}
int main(){
    int D,q,d,resto;
    printf("Escreva o Divisor,quociente:\n");
    scanf("%i\n",&D);
    scanf("%i\n",&q);
    d=div(D,q);
    printf("%d\n",d);
    resto=res_div(D,d,q);
    printf("%d",resto);
}


5.(a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, 
e 0, caso contrário. Siga o seguinte protótipo:

int Primalidade(unsigned int x){
int x,v2,v3,v5,v7,primo;
v2=x%2;
v3=x%3;
v5=x%5;
v7=x%7;
if(v2==1 || v3==1 || v5==1 || v7==0){
primo=1;
}
else
primo=0;

}
avaliar se é divisivel por 2 ou 3 ou 5 ou 7;
caso contrário é primo;

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, 
e o valor de saída também.

6.Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 135*...n, e se n for
par, n!! = 246...n. Por exemplo, 9!! = 13579 = 945 e 10!! = 2468*10 = 3840. Além disso, 0!! = 1!! = 1. O protótipo da função é:

unsigned long long DuploFatorial(unsigned long long n);

7. (a) Escreva uma função em C que calcula a função exponencial utilizando a série de Taylor da mesma. Considere o cálculo até
o termo n = 20. O protótipo da função é 

double ExpTaylor(double x); 

(b) Escreva a sub-rotina equivalente na linguagem Assembly 
do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo
registrador R15, e o valor de saída também.

8.Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente.Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente. [1 2 3 4 5] e [1 2 3 2] não estão. O primeiro endereço do vetor 
é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador 
R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

9.Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, a e b. O primeiro endereço
do vetor a deverá ser passado através do registrador R15, o primeiro endereço do vetor b deverá ser passado através do registrador 
R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

10.(a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo: [1 2 3 2 1] e [0 10 20 20 10 0] 
são palíndromos.[5 4 3 2 1] e [1 2 3 2] não são. Se o vetor for palíndromo, retorne o valor 1. Caso contrário, 
retorne o valor 0. O protótipo da função é:

int Palindromo(int vetor[ ], int tamanho);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador 
R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.
